// =====================================================
// إدارة الطلبات - Orders Management
// =====================================================

// إنشاء طلب جديد
async function createOrder(orderData) {
    // التحقق من حالة المطعم
    const settings = getSettings();
    if (settings && settings.isOpen === false) {
        showToast('عذراً، المطعم مغلق حالياً', 'error');
        throw new Error('Restaurant is closed');
    }

    const cart = getCart();
    
    // Validate Cart Items and Filter Invalid Ones
    // Ensure we only send items with valid meal IDs
    const validItemsPayload = cart
        .filter(item => item.mealId && !isNaN(parseInt(item.mealId)))
        .map(item => ({
            ...item,
            mealId: parseInt(item.mealId), // Explicitly use mealId, ignore item.id (cart ID)
            mealName: item.name,           // Backend expects mealName or name
            size: item.sizeName,           // Backend expects size or sizeName
            price: parseFloat(item.price),
            quantity: parseInt(item.quantity)
        }));

    if (validItemsPayload.length === 0) {
        showToast('السلة تحتوي على عناصر غير صالحة. الرجاء إفراغ السلة.', 'error');
        console.error("Cart has items but no valid mealIds", cart);
        throw new Error('Cart has invalid items');
    }
    
    // Construct Order Object for API
    const subtotal = getCartTotal();
    const deliveryCost = orderData.orderType === 'delivery' 
        ? calculateDeliveryCost(subtotal, orderData.distance || 0) 
        : 0;

    const orderPayload = {
        // id will be generated by DB
        customerName: orderData.customerName,
        customerPhone: orderData.customerPhone,
        customerAddress: orderData.address || '',
        orderType: orderData.orderType,
        location: orderData.location,
        scheduledTime: orderData.scheduledTime,
        notes: orderData.notes,
        subtotal: subtotal,
        deliveryCost: deliveryCost,
        total: subtotal + deliveryCost,
        items: validItemsPayload
    };
    
    // Call data.js submitOrder (which calls ApiClient)
    try {
        const savedOrder = await submitOrder(orderPayload);
        if (savedOrder) {
            clearCart();
            return savedOrder;
        }
    } catch (e) {
        console.error("Order creation failed in logic:", e);
        throw e; // Propagate error to caller for UI handling
    }
    return null;
}


// تحديث حالة الطلب
async function updateOrderStatus(orderId, newStatus) {
    try {
        // Optimistic update in data.js or just wait?
        // updateOrderStatusData is async in data.js
        await updateOrderStatusData(orderId, newStatus);
        
        // Refresh orders if possible or rely on local update
        // The data.js function usually updates local state too.
        return true;
    } catch (e) {
        return false;
    }
}

// الحصول على طلب بواسطة المعرف
function getOrderById(orderId) {
    const orders = getOrders();
    // Ensure loose comparison because ID might be string or int
    return orders.find(o => o.id == orderId); // loose equality
}

// الحصول على طلب بواسطة رقم الطلب
// Note: Backend might use ID as order number or have separate field. 
// My schema has no 'orderNumber' string field? 
// Schema has `id Int`. 
// I should map `orderNumber` to `id` or assume frontend used `id` as number.
// In existing `data.js` and `orders.js`, `orderNumber` was a string.
// Let's treat `orderNumber` as `id` for now to simplify, or check if I added it.
// I did NOT add orderNumber to schema! 
// FIX: I will use `id` as `orderNumber`.
function getOrderByNumber(orderNumber) {
    const orders = getOrders();
    // orderNumber from session might be string
    return orders.find(o => o.id == orderNumber);
}

// الحصول على طلبات الزبون بواسطة رقم الهاتف
function getCustomerOrders(phone) {
    // Ensure we are using the latest state
    const orders = getOrders();
    if (!phone) return [];
    if (!orders) return [];
    
    // Normalize phone (remove spaces, dashes)
    const normalizedPhone = phone.replace(/[\s-]/g, '');
    
    // Sort by Date Descending (Newest First) to ensure new orders appear at top
    return orders.filter(o => {
        if (!o.customerPhone) return false;
        return o.customerPhone.replace(/[\s-]/g, '') === normalizedPhone;
    }).sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
}

// إلغاء الطلب (تغيير الحالة إلى ملغى)
async function cancelOrder(orderId) {
    const order = getOrderById(orderId);
    if (!order) return false;

    if (order.status === 'delivered') {
        showToast('لا يمكن إلغاء طلب تم تسليمه', 'error');
        return false;
    }
    
    // Allow cancellation even if preparing (owner decision), but usually restricted.
    // User requested "Owner can restore".
    
    try {
        // Soft Delete: Update status to 'cancelled_client' to distinguish from admin
        await updateOrderStatus(orderId, 'cancelled_client');
        
        // Optimistic update locally
        order.status = 'cancelled_client';
        
        return true;
    } catch (e) {
        showToast('فشل في إلغاء الطلب', 'error');
        return false;
    }
}

// تقييم الطلب
// تقييم الطلب
async function rateOrder(orderId, rating, review = '') {
    const order = getOrderById(orderId);
    
    if (order && order.status === 'delivered') {
        const previousRating = order.rating;
        const previousReview = order.review;

        // 1. Optimistic Update (Immediate Feedback)
        // Update local memory state instantly
        order.rating = rating;
        order.review = review;
        
        // 2. Persist to Local Storage IMMEDIATELY (Manual Backup)
        // This ensures if user refreshes before API, they see it.
        try {
            // Update the main cached orders array
            let cachedOrders = JSON.parse(localStorage.getItem('cachedOrders') || '[]');
            const cachedIndex = cachedOrders.findIndex(o => o.id == orderId); // loose equality
            
            if (cachedIndex !== -1) {
                cachedOrders[cachedIndex].rating = rating;
                cachedOrders[cachedIndex].review = review;
                localStorage.setItem('cachedOrders', JSON.stringify(cachedOrders));
            }
            
            // Also update 'localOrders' used elsewhere?
            // Just ensuring 'cachedOrders' is enough if app relies on it.
            // Also trigger event to update UI instantly if observing
            document.dispatchEvent(new CustomEvent('orders-updated'));
            
        } catch(e) { console.error("Local save failed", e); }

        // 3. Send to Backend (Background)
        // We don't await this for the UI return, but we handle errors
        ApiClient.request('/orders', {
            method: 'PUT',
            body: JSON.stringify({ id: orderId, rating, review })
        }).catch(e => {
            console.error("Rating sync failed", e);
            // Optional: Revert on HARD failure? 
            // Usually better to keep local state and retry later, 
            // or just silently fail if it's minor.
        });

        // Always return true immediately for "Instant" feel
        showToast('شكراً لتقييمك!', 'success');
        return true;
    }
    return false;
}

// الحصول على حالة الطلب بالعربية
// الحصول على حالة الطلب بالعربية
function getStatusText(status) {
    const statusMap = {
        'new': 'جديد',
        'preparing': 'قيد التحضير',
        'ready': 'جاهز',
        'onTheWay': 'في الطريق',
        'delivered': 'تم التسليم',
        'cancelled': 'ملغي',
        'cancelled_client': 'ملغي من الزبون',
        'cancelled_admin': 'ملغي من الإدارة'
    };
    return statusMap[status] || status;
}

// الحصول على لون حالة الطلب
function getStatusColor(status) {
    const colorMap = {
        'new': '#3498db',
        'preparing': '#f39c12',
        'ready': '#9b59b6',
        'onTheWay': '#1abc9c',
        'delivered': '#27ae60',
        'cancelled': '#e74c3c',
        'cancelled_client': '#e74c3c', // Red
        'cancelled_admin': '#c0392b'   // Darker Red
    };
    return colorMap[status] || '#95a5a6';
}

// إحصائيات الطلبات
function getOrderStats() {
    const orders = getOrders();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Count based on Creation Date (Traffic)
    const todayOrders = orders.filter(o => new Date(o.createdAt) >= today);
    
    // Revenue based on Completion Date (Accounting)
    const completedOrders = orders.filter(o => o.status === 'delivered');

    const weekAgo = new Date();
    weekAgo.setDate(weekAgo.getDate() - 7);
    weekAgo.setHours(0,0,0,0);
    
    const monthAgo = new Date();
    monthAgo.setMonth(monthAgo.getMonth() - 1);
    monthAgo.setHours(0,0,0,0);
    
    // Helper to check date
    const getOrderDate = (o) => new Date(o.completedAt || o.createdAt);

    return {
        total: orders.length,
        today: todayOrders.length,
        // Fix: Use completedAt for revenue
        todayRevenue: completedOrders.reduce((sum, o) => getOrderDate(o) >= today ? sum + o.total : sum, 0),
        
        week: orders.filter(o => new Date(o.createdAt) >= weekAgo).length,
        weekRevenue: completedOrders.reduce((sum, o) => getOrderDate(o) >= weekAgo ? sum + o.total : sum, 0),
        
        month: orders.filter(o => new Date(o.createdAt) >= monthAgo).length,
        monthRevenue: completedOrders.reduce((sum, o) => getOrderDate(o) >= monthAgo ? sum + o.total : sum, 0),
        
        completed: completedOrders.length,
        totalRevenue: completedOrders.reduce((sum, o) => sum + o.total, 0),
        
        pending: orders.filter(o => !['delivered', 'cancelled'].includes(o.status)).length,
        onTheWay: orders.filter(o => o.status === 'onTheWay').length
    };
}

// أكثر الوجبات طلباً
// أكثر الوجبات طلباً
function getPopularMeals(period = 'all') {
    let orders = getOrders().filter(o => o.status === 'delivered');
    
    if (period === 'today') {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        orders = orders.filter(o => new Date(o.createdAt) >= today);
    }
    
    const mealCounts = {};
    
    orders.forEach(order => {
        order.items.forEach(item => {
            const key = `${item.mealId}-${item.sizeName || 'default'}`;
            if (!mealCounts[key]) {
                mealCounts[key] = {
                    id: key,
                    name: item.name,
                    sizeName: item.sizeName,
                    count: 0,
                    revenue: 0
                };
            }
            mealCounts[key].count += item.quantity;
            mealCounts[key].revenue += item.price * item.quantity;
        });
    });
    
    return Object.values(mealCounts)
        .sort((a, b) => b.count - a.count)
        .slice(0, 10);
}
